.step(data-title='Interacting with Appointments', data-file="reminders/views.py", data-language="python")
  h2 Interacting with Appointments

  blockquote 
    | As a user, I want to view a list of all future appointments, and be able to edit and delete those appointments.
  :markdown
    If you're an organization that handles a lot of appointments, you probably want to be able to view and manage them in a single interface. That's what we'll tackle in this user story. We'll create a UI to:

    * Show all appointments
    * Edit individual appointments
    * Delete individual appoinments

    Because these are basic [CRUD-like](http://en.wikipedia.org/wiki/Create,_read,_update_and_delete) operations, we'll keep using [Django's generic class-based views](https://docs.djangoproject.com/en/1.8/topics/class-based-views/generic-editing/#model-forms) to save us a lot of work.

.step(data-title='Showing a list of appointments', data-file="reminders/views.py", data-highlight='5-12', data-language="htmlembedded")
  :markdown
    ## Showing a list of appointments

    Let's tackle showing a list of appointments first.

    Django's [ListView](https://docs.djangoproject.com/en/1.8/ref/class-based-views/generic-display/#listview) class was born for this.

    All we need to do it point it at our `Appointment` model and it will handle building a QuerySet of all appointments for us.

    And wiring up this view in our `reminders/urls.py` module is just as easy as our `AppointmentCreateView`:

  pre
    | from .views import AppointmentListView
    | 
    | url(r'^$', AppointmentListView.as_view(), name='list_appointments'),

  :markdown
    If we name our template file `appointment_list.html` our `AppointmentListView` will find it automatically. Let's check it out next.

.step(data-title="Appointment list template", data-file="templates/reminders/appointment_list.html", data-language="htmlembedded")
  :markdown
    ## Appointment list template

    Our `AppointmentListView` passes its list of appointment objects to our template in the `object_list` variable.

    If that variable is empty, we include a `<p>` tag saying there are no upcoming appointments.

    Otherwise we populate a table with a row for each appointment in our list. We can use our handy `get_absolute_url` method again to include a link to each appointment's detail page.

    We also use the [{% url %}](https://docs.djangoproject.com/en/1.8/ref/templates/builtins/#url) template tag to include links to our edit and delete views.

    And now that our appointment listing requirement is complete, let's cover how to build those views next.

.step(data-title="Tweaking our form template", data-file="templates/reminders/appointment_form.html", data-highlight="44-57" data-language="htmlembedded")
  :markdown
    ## Tweaking our form template

    Django's [UpdateView](https://docs.djangoproject.com/en/1.8/ref/class-based-views/generic-editing/#django.views.generic.edit.UpdateView) makes it easy to add a view for updating appointments. Our form template needs a few tweaks, though, to handle prepopulated data from an existing appointment.

    Django will store our datetimes precisely, down to the second, but we don't want to bother our users by forcing them to pick the precise second an appointment starts.

    To fix this problem we use the [extraFormats configuration option](https://eonasdan.github.io/bootstrap-datetimepicker/Options/#extraformats) of bootstrap-datetimepicker. 

    By configuring our datetimepicker with a `format` value that doesn't ask users for seconds, and an `extraFormat` value that does accept datetimes with seconds, our form will populate correctly when Django provides a full datetime to our template.

.step(data-title="Delete view", data-file="reminders/views.py", data-language="python")
  :markdown
    ## Delete view

    [DeleteView](https://docs.djangoproject.com/en/1.8/ref/class-based-views/generic-editing/#django.views.generic.edit.DeleteView) is an especially handy view class. It shows users a confirmation page before deleting the specified object.

    Like UpdateView, DeleteView finds the object to delete by using the `pk` parameter in its URL, declared in `reminders/urls.py`:

  pre
    | from .views import AppointmentDeleteView
    | 
    | url(r'^/(?P<pk>[0-9]+)/delete$', AppointmentDeleteView.as_view(), name='delete_appointment'),

  :markdown
    We also need to specify a `success_url` property on our view class. This property tells Django where to send users after a successful deletion. In our case, we'll send them back to the list of appointments at the URL named `list_appointments`.

    When a Django project starts running, it evaluates views before URLs, so we need to use the [reverse_lazy](https://docs.djangoproject.com/en/1.8/ref/urlresolvers/#reverse-lazy) utility function to get our appointment list URL instead of `reverse`.

    By default, our `AppointmentDeleteView` will look for a template named `appointment_confirm_delete.html`. You can check out ours in the `templates/reminders` directory.

    And that closes out this user story.

    Our users now have everything they need to manage appointments - all that's left to implement is sending the reminders.
