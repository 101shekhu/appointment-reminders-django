.step(data-title='Sending the Reminder', data-file="reminders/tasks.py", data-language="python")
  h2 Sending the Reminder
  blockquote
    | As an appointment system, I want to notify a customer via SMS an arbitrary interval before a future appointment.
  :markdown
    To satisfy this user story, we need to make our application work asynchronously - on its own independent of any individual user interaction.

    The most popular Python library for asynchronous tasks is [Celery](http://www.celeryproject.org/). To integrate Celery with our application, we need to make a few changes:

    - Create a new function that sends an SMS message using information from an `Appointment` object
    - Register that function as a task with Celery so it can be executed asynchronously
    - Run a separate Celery worker process alongside our Django application to call our SMS reminder function at the right time for each appointment

    If you're brand new to Celery, you might want to skim its [Introduction to Celery](http://docs.celeryproject.org/en/latest/getting-started/introduction.html) page before proceeding.

.step(data-title="Setting up Celery", data-file="appointments/settings/common.py", data-language="python", data-highlight="29-31")
  :markdown
    ## Setting up Celery

    Celery and Django are both big Python projects, but they can work together easily.

    [By following the instructions in the Celery docs](http://docs.celeryproject.org/en/latest/django/first-steps-with-django.html), we can include our Celery settings in our Django settings modules. We can also write our Celery tasks in `tasks.py` modules that live inside our Django apps, which keeps our project layout consistent and simple.

    To use Celery, you also need a separate service to be your message broker. We used [Redis](http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html#broker-redis) for this project.

    The two Celery-specific settings in our `common.py` settings module are `BROKER_URL` and `BROKER_POOL_LIMIT`.

    `BROKER_POOL_LIMIT` limits how many connections Celery will make to our broker - useful when deploying to a Platform-as-a-Service (PaaS) like [Heroku](https://www.heroku.com/) where the free tiers of Redis services limit your application to a handful of connections.

    If you want to see all the steps to get Django, Celery, Redis, and Postgres working on your machine [check out the README for this project on GitHub](https://github.com/TwilioDevEd/appointment-reminders-django).

.step(data-title="Creating a Celery task", data-file="reminders/tasks.py", data-highlight="15-25", data-language="python")
  :markdown
    ## Creating a Celery task

    Now that Celery is working with our project, it's time to write a new task for sending a customer an SMS message about their appointment.

    Our task takes an appointment's ID - it's primary key - as its only argument. We could pass the `Appointment` object itself as the argument, but this best practice ensures our SMS will use the most up-to-date version of our appointment's data.

    It also gives us an opportunity to check if the appointment has been deleted before the reminder was sent, which we do at the top of our function. This way we won't send SMS reminders for appointments that don't exist anymore.

.step(data-title="Sending an SMS message", data-file="reminders/tasks.py", data-language="python")
  :markdown
    ## Sending an SMS message

    The next step in our `send_sms_reminder` task is to compose the text of our SMS message.

    We use the handy [arrow](http://crsmithdev.com/arrow/) library to format our appointment's time. After that, we use the [twilio-python](https://github.com/twilio/twilio-python) library to send our message.

    We instantiate a Twilio REST client at the top of the module, which looks for `TWILIO_ACCOUNT_SID` and `TWILIO_AUTH_TOKEN` environment variables to authenticate itself. You can find the correct values for you in [your account dashboard](https://www.twilio.com/user/account/settings).

    Sending the SMS message itself is as easy as calling `client.messages.create()`, passing arguments for the body of the SMS message, the receipient's phone number, and the Twilio phone number you want to send this message from. Twilio will deliver the SMS message immediately.

    With our `send_sms_reminder` task complete, let's look at how to call it when our appointments are created or updated.

.step(data-title="Calling our reminder task", data-file="reminders/models.py", data-highlight="39-50", data-language="python")
  :markdown
    ## Calling our reminder task

    We added a new method on our `Appointment` model to help schedule a reminder for an individual appointment.

    Our method starts by using [arrow](http://crsmithdev.com/arrow/) again to build a new datetime with the appointment's `time` and `time_zone`.

    Moving backward in time can be tricky in normal Python, but arrow's `.replace()` method lets us easily subtract minutes from our `appointment_time`. The `REMINDER_TIME` setting defaults to 30 minutes.

    We finish by invoking our Celery task, using the [eta](http://docs.celeryproject.org/en/latest/userguide/calling.html#eta-and-countdown) parameter to tell Celery when this task should execute.

    We can't import the `send_sms_reminder` task at the top of our `models.py` module because the `tasks.py` module imports the `Appointment` model. Importing it in our `schedule_reminder` method avoids a circular dependency.

.step(data-title="Overriding the Appointment save method", data-file="reminders/models.py", data-language="python", data-highlight="52-68")
  :markdown
    ## Overriding the Appointment save method

    The last thing we need to do is ensure Django calls our `schedule_reminder` method every time an `Appointment` object is created or updated.

    The best way to do that is to [override our model's save method](https://docs.djangoproject.com/en/1.8/topics/db/models/#overriding-predefined-model-methods), including an extra call to `schedule_reminder` after the object's primary key has been assigned.

    **Avoiding duplicate or mistimed reminders**

    Scheduling a Celery task every time an appointment is saved has an unfortunate side effect - our customers will receive duplicate reminders if an appointment was saved more than once. And those reminders could be sent at the wrong time if an appointment's `time` field was changed after its creation.

    To fix this, we keep track of each appointment's reminder task through the `task_id` field, which stores Celery's unique identifier for each task.

    We then look for a previously scheduled task at the top of our custom `save` method and [revoke](http://celery.readthedocs.org/en/latest/faq.html#can-i-cancel-the-execution-of-a-task) it if present.

    This guarantees that one and exactly one reminder will be sent for each appointment in our database, and that it will be sent at the most recent `time` provided for that appointment.

.step(data-title="Finished", data-file="reminders/models.py", data-language="python")
  :markdown
    ## Finished

    Our appointments project is now complete!

    We used [Django's class-based views](https://docs.djangoproject.com/en/1.8/topics/class-based-views/) to help us quickly build out the features to support simple CRUD operations on our `Appointment` model.

    We then integrated [Celery](http://www.celeryproject.org/) into our project and used the [twilio-python](https://github.com/twilio/twilio-python) helper library to send SMS reminders about our appointments asynchronously.

    You'll find instructions to run this project locally in [its GitHub README](https://github.com/TwilioDevEd/appointment-reminders-django). You can also deploy this project to Heroku in moments by following instructions in the same place.


    ### Did this help?

    Thanks for checking this tutorial out! If you have any feedback
    to share with us, we'd love to hear it. [Contact the Twilio
    Developer Education Team](mailto:deved-oss@twilio.com) to let us
    know what you think.
